var fs = require('fs'),
    path = require('path'),
    async = require('async');

// TODO: Switch over to a static file creator and file watching (don't forget about creation of new files -- directory watching? or async setTimeout that watches dir)

// TODO: Implement RSS

// TODO: Make separate methods for base page, article page, and rss which are tied back to jojo

/**
 * jojo - 10 second blog engine for hackers (in javascript)
 * @param {Object<ExpressServer>} [app] App to write to
 * @param {Object} [options] Various options corresponding to jojo
 * @param {String} [options.baseRoute='/'] Route where the base file will be rendered
 * @param {String} [options.templateEngine='ejs'] Route where the base file will be rendered
 * @param {String} [options.templateDir='templates'] Directory to retrieve templates from
 * @param {String} [options.articleDir='articles'] Directory to retrieve articles from
 * @param {Function} [options.formatter='showdown'] Processor used for articles // TODO: name this proeprly
 * @returns {Object<ExpressServer>} Express server initiall passed or created with the proper routes
 */
function jojo(req, res, next) {
  // Grab the url, jojoBase
  // TODO: Figure out how to use express route testing
  var url = req.url,
      app = req.app,
      settings = app.settings,
      basepath = settings['jojo basepath'] || '/',
      cwd = process.cwd(),
      articleDir = settings['jojo articles'] || path.join(cwd, 'articles'),
      yoyo = new Yoyo(app),
      indexView = settings['jojo index view'] || 'pages/index',
      articleView = settings['jojo article view'] || 'pages/article',
      baseIndex;

  // If we are in the base route
  if (url === basepath) {
    // and there is an index view
    if (indexView) {
      // Generate an index page with articles
      return yoyo.readArticles(articleDir, function (err, articles) {
        // If there is an error, log it and move to next fn
        if (err) {
          console.error(err);
          return next();
        }

        // Otherwise, render
        // TODO: Figure out how to include view data that we don't know about
        res.render(indexView, {'title': 'TESTING', 'articles': articles});
      });
    }
  } else {
    baseIndex = url.indexOf(basepath);
    if (baseIndex !== -1) {
    // Otherwise, attempt to find a matching article
      return yoyo.readArticles(articleDir, function (err, articles) {
        // If there is an error, log it and run the next function
        if (err) {
          console.error(err);
          return next();
        }

        // Iterate the files
        var articleUrl = url.slice(baseIndex + 1),
            i = 0,
            len = articles.length,
            article,
            articleFound = false;
        for (; i < len; i++) {
          article = articles[i];

          // If it matches our article url, save it
          if (articleUrl.indexOf(article.url) !== -1) {
            articleFound = true;
            break;
          }
        }

        // If the article was found, use it
        if (articleFound) {
          // TODO: Proper config item
          article.config = app.settings;

          // If there is an articleView, render through it
          if (articleView !== undefined) {
            // TODO: Allow for alternative jojo render engine?
            res.render(articleView, article);
          } else {
          // Otherwise, send the content
            res.send(article.content);
          }
        } else {
          // Otherwise, call the next method
          next();
        }
      });
    }
  }

  // Otherwise, call the next method
  next();
}

// Sugar method for creating a server
jojo.createServer = function () {
  // Create a server an express server
  var express = require('express'),
      server = express.createServer.apply(express, arguments);

  // Bind jojo to the server
  server.use(jojo);

  // Return the bound server
  return server;
};

// TODO: jojo.static which preloads views and does not dynamically fetch during each request

// State (and sanity) preserver for jojo
function Yoyo(app) {
  // Fallback app
  app = app || {'settings': {}};

  // Save app to this
  this.app = app;
}
Yoyo.prototype = {
  'readArticles': function (articleDir, callback) {
    var that = this;
    fs.readdir(articleDir, function (err, articles) {
      // If there is an error, log and callback with it
      if (err) {
        console.error('Article directory could not be read: ', articleDir);
        return callback(err);
      }

      // Otherwise, read in all of the articles
      async.map(articles, function (article, callback) {
        var articlePath = path.join(articleDir, article);
        that.readArticle(articlePath, callback);
      }, callback);
    });
  },
  'readArticle': function (articlePath, callback) {
    var that = this;
    fs.readFile(articlePath, 'utf8', function (err, article) {
      // If there was an error, log it
      if (err) {
        console.error('An article could not be read: ', articlePath);
        return callback(err);
      }

      // Otherwise, parse the article
      var parsedArticle = that.parseArticle(article);

      // Callback with the article
      callback(null, parsedArticle);
    });
  },
  'parseArticle': function (article) {
    var app = this.app,
        settings = app.settings,
        dataEngine = settings['jojo data parser'] || 'json',
        formatEngine = settings['jojo formatter'] || 'showdown',
        formatter = require(formatEngine),
        dataParser = dataEngine === 'json' ? JSON.parse : require(dataEngine);

    // If the engine is showdown, get the proper formatter
    if (formatEngine === 'showdown') {
      // This is so wrong... on so many levels... =_=
      var tempThis = {};
      formatter.Showdown.converter.call(tempThis);
      formatter = tempThis.makeHtml;
    }

    // TODO: This is what cloudhead uses but I am not too fond of it
    // Find where the JSON ends (denoted by a double line break)
    var dblLineBreakIndex = article.search(/\n\r?\n/g);

    // Fallback the dblLineBreakIndex
    if (dblLineBreakIndex === -1) {
      dblLineBreakIndex = article.length;
    }

    // Break up the properties and content
    var propsStr = article.slice(0, dblLineBreakIndex),
        props = new Function('return ' + propsStr + ';')(),
        rawContent = article.slice(dblLineBreakIndex);

    // Render the content via the formatter
    var content = formatter(rawContent),
        retObj = dataParser(propsStr);

    // Save the content to the renderObj
    retObj.content = content;

    // Fallback the url
    retObj.url = retObj.url || jojo.getUrl(retObj);

    // Return the parsed object
    return retObj;
  }
};

// Expose Yoyo via jojo
jojo.Yoyo = Yoyo;

// Create a overwritable helper function for generating article URLs
jojo.getUrl = function (article) {
  var urlParts = [],
      date = article.date;
  if (date) {
    urlParts.push(date.replace(/\//g, '-'));
  }
  urlParts.push(article.title.replace(/\s+/g, '-'));

  return urlParts.join('-').toLowerCase();
}

// Create helper methods for reading and parsing articles
var emptyYoyo = new Yoyo();
jojo.readArticles = function (articleDir, callback) {
  emptyYoyo.readArticles(articleDir, callback);
};
jojo.readArticle = function (articlePath, callback) {
  emptyYoyo.readArticle(articlePath, callback);
};
jojo.parseArticle = function (article) {
  emptyYoyo.parseArticle(article);
};

// Export jojo
module.exports = jojo;