var fs = require('fs'),
    path = require('path'),
    url = require('url'),
    async = require('async');

// TODO: Switch over to a static file creator and file watching (don't forget about creation of new files -- directory watching? or async setTimeout that watches dir)

// TODO: Implement RSS

/**
 * jojo - 10 second blog engine for hackers (in javascript)
 * @param {Object<ExpressServer>} [app] App to write to
 * @param {Object} [options] Various options corresponding to jojo
 * @param {String} [options.baseRoute='/'] Route where the base file will be rendered
 * @param {String} [options.templateEngine='ejs'] Route where the base file will be rendered
 * @param {String} [options.templateDir='templates'] Directory to retrieve templates from
 * @param {String} [options.articleDir='articles'] Directory to retrieve articles from
 * @param {Function} [options.formatter='showdown'] Processor used for articles // TODO: name this proeprly
 * @returns {Object<ExpressServer>} Express server initiall passed or created with the proper routes
 */
function jojo(req, res, next) {
  // Grab the url, jojoBase
  // TODO: Figure out how to use express route testing
  var url = req.url,
      app = req.app,
      settings = app.settings,
      basepath = settings['jojo basepath'] || '/',
      cwd = process.cwd(),
      articleDir = settings['jojo articles'] || path.join(cwd, 'articles'),
      dataEngine = settings['jojo data parser'] || 'json',
      formatEngine = settings['jojo formatter'] || 'showdown',
      indexView = settings['jojo index view'],
      articleView = settings['jojo article view'],
      baseIndex;

  // If we are in the base route
  if (url === basepath) {
    // and there is an index view
    if (indexView) {
      // TODO: Index page with articles
      return res.render(indexView, 'Post summary');
    }
  } else {
    baseIndex = url.indexOf(basepath);
    if (baseIndex !== -1) {
    // TODO: Abstract this into a jojo.readArticles (and readArticlesSync?) function
    // Otherwise, attempt to find a matching article
      return readArticles(articleDir, function (err, fileNames) {
        // If there is an error, log it and run the next function
        if (err) {
          console.error(err);
          return next();
        }

        var articleUrl = url.slice(baseIndex + 1);

        // Iterate the files
        var i = 0,
            len = fileNames.length,
            fileName,
            fileParts,
            articleName,
            fileFound = false;
        for (; i < len; i++) {
          fileName = fileNames[i];

          // Remove the extension from the file
          fileParts = fileName.split('.');
          if (fileParts.length > 1) {
            fileParts.pop();
          }

          // If it matches our article url, save it
          articleName = fileParts.join('.');
          if (articleUrl.indexOf(articleName) !== -1) {
            fileFound = true;
            break;
          }
        }

        // If the file was found, interpret it
        if (fileFound) {
          fs.readFile(path.join(articleDir, fileName), 'utf8', function (err, file) {
            // If there was an error, log it and call the next method
            if (err) {
              console.error('Article could not be read: ', fileName);
              console.error(err);
              return next();
            }

            // Grab the formatter
            var formatter = require(formatEngine);

            // If the engine is showdown, get the proper formatter
            if (formatEngine === 'showdown') {
              // This is so wrong... on so many levels... =_=
              var tempThis = {};
              formatter.Showdown.converter.call(tempThis);
              formatter = tempThis.makeHtml;
            }

            // Grab the data parser
            var dataParser = dataEngine === 'json' ? JSON : require(dataEngine);
            dataParser = dataParser.parse || dataParser;

            // TODO: This is what cloudhead uses but I am not too fond of it
            // Find where the JSON ends (denoted by a double line break)
            var dblLineBreakIndex = file.search(/\n\r?\n/g);

            // Fallback the dblLineBreakIndex
            if (dblLineBreakIndex === -1) {
              dblLineBreakIndex = file.length;
            }

            // Break up the properties and content
            var propsStr = file.slice(0, dblLineBreakIndex),
                props = new Function('return ' + propsStr + ';')(),
                rawContent = file.slice(dblLineBreakIndex);

            // Render the content via the formatter
            var content = formatter(rawContent),
                renderObj = dataParser(propsStr);

            // Save the content to the renderObj
            renderObj.content = content;

            // TODO: Proper config item
            renderObj.config = app.settings;

            // If there is an articleView, render through it
            if (articleView !== undefined) {
              // TODO: Allow for alternative jojo render engine?
              res.render(articleView, renderObj);
            } else {
            // Otherwise, use res.send
              res.send(content);
            }
          });
        } else {
          // Otherwise, call the next method
          next();
        }
      });
    }
  }
  // Otherwise, call the next method
  next();
}

// Sugar method for creating a server
jojo.createServer = function () {
  // Create a server an express server
  var express = require('express'),
      server = express.createServer.apply(express, arguments);

  // Bind jojo to the server
  server.use(jojo);

  // Return the bound server
  return server;
};

// TODO: jojo.static which preloads views and does not dynamically fetch during each request

// Helper method for reading articles
function readArticles(articleDir, callback) {
  fs.readdir(articleDir, function (err, articles) {
    // If there is an error, log and callback with it
    if (err) {
      console.error('Article directory could not be read: ', articleDir);
      return callback(err);
    }

    // Otherwise, read in all of the articles
    async.map(articles, function (article, callback) {
      var articlePath = path.join(articleDir, article);
      readArticle(articlePath, 'utf8', callback);
    }, callback);
  });
}
jojo.readArticles = readArticles;

// Reader for a single article
function readArticle(articlePath, callback) {
  fs.readFile(articlePath, 'utf8', function (err, article) {
    // If there was an error, log it
    if (err) {
      console.error('An article could not be read: ', articlePath);
      return callback(err);
    }

    // Otherwise, parse the article
    var parsedArticle = parseArticle(article);

    // Callback with the article
    callback(null, parsedArticle);
  });
}
jojo.readArticle = readArticle;

// Parse a single article
function parseArticle(article) {
  // TODO: Need settings
  return article;
}
jojo.parseArticle = parseArticle;

// Export jojo
module.exports = jojo;