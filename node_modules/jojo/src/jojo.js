var fs = require('fs'),
    path = require('path');

/**
 * jojo - 10 second blog engine for hackers (in javascript)
 * @param {Object<ExpressServer>} [app] App to write to
 * @param {Object} [options] Various options corresponding to jojo
 * @param {String} [options.baseRoute='/'] Route where the base file will be rendered
 * @param {String} [options.templateEngine='ejs'] Route where the base file will be rendered
 * @param {String} [options.templateDir='templates'] Directory to retrieve templates from
 * @param {String} [options.articleDir='articles'] Directory to retrieve articles from
 * @param {Function} [options.formatter='showdown'] Processor used for articles // TODO: name this proeprly
 * @returns {Object<ExpressServer>} Express server initiall passed or created with the proper routes
 */
function jojo(req, res, next) {
  // Grab the url, jojoBase
  // TODO: Figure out how to use express route testing
  var url = req.url,
      app = req.app,
      baseRoute = app.settings['jojo base'] || '/',
      baseRegExp = typeof baseRoute === 'string' ? new RegExp(baseRoute, 'i') : baseRoute,
      articleDir = app.settings['jojo articles'] || 'articles';

  if (baseRegExp.test(url)) {
    console.log('heyooo');
  } else if (url) {
  
  }

  // Call the next method
  next();
}

// Sugar method for creating a server
jojo.createServer = function () {
  // Create a server an express server
  var express = require('express'),
      server = express.createServer.apply(express, arguments);

  // Bind jojo to the server
  server.use(jojo);

  // Return the bound server
  return server;
};

// TODO: jojo.static which preloads views and does not dynamically fetch during each request

// Explicit method for binding of server
jojo.bindTo = function (app, options) {
  // Fallback options
  options = options || {};

  // TODO: Write options to express (only if we have the possibility for re-using them...)
  // TODO: Definitely fetch jojo options first off of express app (like template engine)
  var baseRoute = options.baseRoute || '/',
      templateEngine = options.templateEngine || 'ejs',
      templateDir = options.templateDir || 'templates',
      articleDir = options.articleDir || 'articles',
      formatter = options.formatter;

  // If the formatter is not defined, fallback to showdown
  if (formatter === undefined) {
    // This is so wrong... on so many levels... =_=
    var tempThis = {};
    require('showdown').Showdown.converter.call(tempThis);
    formatter = tempThis.makeHtml;
  }

  // Read in all the files in the article directory
  var fileNames = fs.readdirSync(articleDir),
      articles = [];
  fileNames.forEach(function (fileName) {
    // Read in the article
    var filepath = path.join(articleDir, fileName),
        file = fs.readFileSync(filepath, 'utf8');

    // TODO: Watch file for changes?

    // TODO: This is what cloudhead uses but I am not too fond of it
    // Find where the JSON ends (denoted by a double line break)
    var dblLineBreakIndex = file.search(/\n\r?\n/g);

    // Fallback the dblLineBreakIndex
    if (dblLineBreakIndex === -1) {
      dblLineBreakIndex = file.length;
    }

    // Break up the properties and content
    var propsStr = file.slice(0, dblLineBreakIndex),
        props = new Function('return ' + propsStr + ';')(),
        rawContent = file.slice(dblLineBreakIndex);

    // Render the content via the formatter
    var content = formatter(rawContent);

    // TODO: Generate and save article object -- don't forget date, summary, content = body
  });

  // TODO: Index page with articles
  // TODO: Restore config.callouts (config should not be a local variable?)
};

// Export jojo
module.exports = jojo;